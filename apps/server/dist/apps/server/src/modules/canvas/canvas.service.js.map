{
  "version": 3,
  "sources": ["../../../../../../src/modules/canvas/canvas.service.ts"],
  "sourcesContent": ["import { CanvasCreationAttributes, CanvasQueryAttributes, CanvasUpdateAttributes } from \"./canvas.model\";\r\nimport { Op, Transaction } from 'sequelize';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { Canvas, Note } from \"../shared/model/model.relation\";\r\nimport sequelize from \"../../config/database\";\r\nimport redisClient from \"../../config/redis\";\r\nimport { paginateAndSort } from \"../../common/utils/pagination.utils\";\r\n\r\n// Helper: Deletes all list caches recorded in the user's tracker\r\nconst invalidateUserCache = async (userId: number) => {\r\n    const trackerKey = `user:${userId}:canvas_cache_tracker`;\r\n    const keysToDelete = await redisClient.sMembers(trackerKey);\r\n\r\n    if (keysToDelete.length > 0) {\r\n        const pipeline = redisClient.multi();\r\n        pipeline.del(keysToDelete); // Delete the actual cached lists\r\n        pipeline.del(trackerKey);   // Delete the tracker itself\r\n        await pipeline.exec();\r\n        console.log(`Invalidated ${keysToDelete.length} canvas cache keys for user ${userId}`);\r\n    }\r\n};\r\nexport const createCanvasService = async (data: CanvasCreationAttributes, userId: number): Promise<Canvas> => {\r\n    const transaction: Transaction = await sequelize.transaction();\r\n\r\n    try {\r\n        const canvas_uid = uuidv4();\r\n\r\n        // If note_id is provided, verify it exists and belongs to the user\r\n        if (data.note_id) {\r\n            const note = await Note.findOne({\r\n                where: { id: data.note_id, user_id: userId },\r\n                transaction\r\n            });\r\n\r\n            if (!note) {\r\n                throw new Error('Associated note not found or does not belong to user');\r\n            }\r\n        }\r\n\r\n        const canvasData = {\r\n            ...data,\r\n            user_id: userId,\r\n            canvas_uid,\r\n            created_at: new Date(),\r\n            updated_at: new Date(),\r\n        };\r\n\r\n        const canvas = await Canvas.create(canvasData, { transaction });\r\n\r\n        await transaction.commit();\r\n        await invalidateUserCache(userId);\r\n\r\n        return canvas;\r\n    } catch (error) {\r\n        await transaction.rollback();\r\n        console.error('Error creating canvas:', error);\r\n        throw error;\r\n    }\r\n};\r\n\r\nexport const getAllCanvasesService = async (\r\n    userId: number,\r\n    filters: CanvasQueryAttributes = {}\r\n): Promise<{ data: Canvas[], meta: any }> => {\r\n    try {\r\n        const {\r\n            search,\r\n            page = 1,\r\n            limit = 10,\r\n            ...modelFilters\r\n        } = filters;\r\n\r\n        // Calculate offset from page\r\n        const offset = (page - 1) * limit;\r\n\r\n        // Generate Redis key similar to notes service\r\n        const redisKeyGen = `canvases:${userId}:${limit}:${offset}:${search || ''}:${JSON.stringify(modelFilters)}`;\r\n        const trackerKey = `user:${userId}:canvas_cache_tracker`;\r\n\r\n        const cachedCanvases = await redisClient.get(redisKeyGen);\r\n        if (cachedCanvases) {\r\n            console.log('Canvases found in cache');\r\n            return JSON.parse(cachedCanvases);\r\n        }\r\n\r\n        console.log('Canvases not found in cache');\r\n\r\n        const whereClause: any = { user_id: userId };\r\n\r\n        // Apply model-based filters\r\n        if (modelFilters.id !== undefined) whereClause.id = modelFilters.id;\r\n        if (modelFilters.canvas_uid !== undefined) whereClause.canvas_uid = modelFilters.canvas_uid;\r\n        if (modelFilters.note_id !== undefined) whereClause.note_id = modelFilters.note_id;\r\n        if (modelFilters.pinned !== undefined) whereClause.pinned = modelFilters.pinned;\r\n        if (modelFilters.created_at !== undefined) whereClause.created_at = modelFilters.created_at;\r\n        if (modelFilters.updated_at !== undefined) whereClause.updated_at = modelFilters.updated_at;\r\n\r\n        // Handle title filter (exact or partial match)\r\n        if (modelFilters.title !== undefined) {\r\n            whereClause.title = modelFilters.title;\r\n        }\r\n\r\n        // Handle search (overrides title filter for partial match)\r\n        if (search) {\r\n            whereClause.title = { [Op.iLike]: `%${search}%` };\r\n        }\r\n\r\n        const result = await paginateAndSort<Canvas>(\r\n            Canvas,\r\n            whereClause,\r\n            page,\r\n            limit,\r\n            [['updated_at', 'DESC']],\r\n            [\r\n                {\r\n                    model: Note,\r\n                    as: 'note',\r\n                    attributes: ['id', 'title', 'note_uid', 'created_at', 'updated_at'],\r\n                    required: false\r\n                }\r\n            ],\r\n            ['id', 'canvas_uid', 'user_id', 'note_id', 'title', 'pinned', 'created_at', 'updated_at']\r\n\r\n        );\r\n\r\n        // Cache using pipeline like notes service\r\n        const pipeline = redisClient.multi();\r\n        pipeline.set(redisKeyGen, JSON.stringify(result), {\r\n            EX: 60 * 60, // 1 hour\r\n        });\r\n        pipeline.sAdd(trackerKey, redisKeyGen);\r\n        pipeline.expire(trackerKey, 60 * 60);\r\n\r\n        await pipeline.exec();\r\n\r\n        return result;\r\n    } catch (error) {\r\n        console.error('Error fetching canvases:', error);\r\n        throw error;\r\n    }\r\n};\r\n\r\nexport const getCanvasByUidService = async (uid: string, userId: number): Promise<Canvas | null> => {\r\n    try {\r\n        const cacheKey = `canvas:${uid}:${userId}`;\r\n\r\n        const cachedCanvas = await redisClient.get(cacheKey);\r\n        if (cachedCanvas) {\r\n            console.log('Canvas found in cache');\r\n            return JSON.parse(cachedCanvas);\r\n        }\r\n\r\n        console.log('Canvas not found in cache');\r\n\r\n        const canvas = await Canvas.findOne({\r\n            where: { canvas_uid: uid, user_id: userId },\r\n            include: [\r\n                {\r\n                    model: Note,\r\n                    as: 'note',\r\n                    attributes: ['id', 'title', 'note_uid', 'content', 'created_at', 'updated_at']\r\n                }\r\n            ],\r\n            raw: true,\r\n            nest: true,\r\n        });\r\n\r\n        if (canvas) {\r\n            await redisClient.set(cacheKey, JSON.stringify(canvas), {\r\n                EX: 60 * 30, // Cache for 30 minutes\r\n            });\r\n        }\r\n\r\n        console.log('Fetched canvas by uid:', uid, canvas ? 'found' : 'not found');\r\n        return canvas;\r\n    } catch (error) {\r\n        console.error('Error fetching canvas:', error);\r\n        throw error;\r\n    }\r\n};\r\n\r\nexport const updateCanvasService = async (\r\n    id: number,\r\n    data: CanvasUpdateAttributes,\r\n    userId: number\r\n): Promise<Canvas | null> => {\r\n    const transaction: Transaction = await sequelize.transaction();\r\n\r\n    try {\r\n        // 1. Check canvas ownership\r\n        const existingCanvas = await Canvas.findOne({\r\n            where: { id, user_id: userId },\r\n            transaction,\r\n        });\r\n\r\n        if (!existingCanvas) {\r\n            throw new Error(\"Canvas not found\");\r\n        }\r\n        console.log(\"note id \", data.note_id)\r\n        // 2. If note_id is being updated, verify the note exists and belongs to user\r\n        if (data.note_id !== undefined && data.note_id !== null) {\r\n            const note = await Note.findOne({\r\n                where: { id: data.note_id, user_id: userId },\r\n                transaction\r\n            });\r\n\r\n            if (!note) {\r\n                throw new Error('Associated note not found or does not belong to user');\r\n            }\r\n\r\n            // If note exists and has document_data, update it\r\n            if (data.document_data) {\r\n                await Note.update(\r\n                    {\r\n                        content: data.document_data,\r\n                        updated_at: new Date()\r\n                    },\r\n                    {\r\n                        where: { id: data.note_id, user_id: userId },\r\n                        transaction\r\n                    }\r\n                );\r\n            }\r\n        }\r\n\r\n        const updateData = {\r\n            ...data,\r\n            updated_at: new Date(),\r\n        };\r\n\r\n        // 3. Update canvas inside transaction\r\n        await Canvas.update(updateData, {\r\n            where: { id, user_id: userId },\r\n            transaction,\r\n        });\r\n\r\n        await redisClient.del(`canvas:${existingCanvas.dataValues.canvas_uid}:${userId}`);\r\n        await invalidateUserCache(userId);\r\n\r\n        // 4. Commit transaction\r\n        await transaction.commit();\r\n\r\n        // 5. Fetch and return updated canvas\r\n        return await Canvas.findByPk(id, {\r\n            include: [\r\n                {\r\n                    model: Note,\r\n                    as: 'note',\r\n                    attributes: ['id', 'title', 'note_uid', 'content', 'created_at', 'updated_at']\r\n                }\r\n            ],\r\n            raw: true,\r\n            nest: true,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Error updating canvas:\", error);\r\n        await transaction.rollback();\r\n        throw error;\r\n    }\r\n};\r\n\r\nexport const deleteCanvasService = async (id: number, userId: number): Promise<boolean> => {\r\n    try {\r\n        const canvas = await Canvas.findOne({\r\n            where: { id: id, user_id: userId },\r\n            raw: true,\r\n            attributes: ['canvas_uid']\r\n        });\r\n\r\n        if (!canvas) {\r\n            return false;\r\n        }\r\n\r\n        const deletedRows = await Canvas.destroy({\r\n            where: { id, user_id: userId }\r\n        });\r\n\r\n        if (deletedRows > 0) {\r\n            await redisClient.del(`canvas:${canvas.canvas_uid}:${userId}`);\r\n            await invalidateUserCache(userId);\r\n        }\r\n\r\n        return deletedRows > 0;\r\n    } catch (error) {\r\n        console.error('Error deleting canvas:', error);\r\n        throw error;\r\n    }\r\n};\r\n"],
  "mappings": "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",
  "names": ["redisClient", "sequelize", "uuidv4"]
}
