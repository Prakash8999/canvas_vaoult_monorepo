{
  "version": 3,
  "sources": ["../../../../../../src/modules/users/user.service.ts"],
  "sourcesContent": ["import bcrypt from 'bcrypt';\r\nimport crypto from 'crypto';\r\nimport { User, UserCreationAttributes } from './users.model';\r\nimport redisClient from '../../config/redis';\r\nimport { otpQueue } from '../../jobs/producer';\r\nimport { createRefreshToken, generateAccessToken, setRefreshTokenCookie } from '../../common/utils/authTokenService';\r\nimport { Request, Response } from 'express';\r\nimport { v4 } from 'uuid';\r\nimport { redisKey } from '../../common/utils/redisKey';\r\n\r\n\r\nexport async function createUserService(body: UserCreationAttributes) {\r\n  if (!User || !User.sequelize) throw new Error('Database not initialized');\r\n\r\n  const existing = await User.count({ where: { email: body.email } });\r\n  console.log('Existing user count:', existing);\r\n  if (existing > 0) {\r\n    const err: any = new Error('User already exists');\r\n    err.statusCode = 409;\r\n    throw err;\r\n  }\r\n\r\n  const otp = Math.floor(100000 + Math.random() * 900000).toString();\r\n\r\n  // callback transaction\r\n  const user = await User.sequelize.transaction(async (t) => {\r\n    const hashedPassword = await bcrypt.hash(body.password, 10);\r\n    const addData = {\r\n      ...body,\r\n      password: hashedPassword,\r\n      created_at: new Date(),\r\n      updated_at: new Date(),\r\n      is_email_verified: false,\r\n      block: false,\r\n    };\r\n\r\n    try {\r\n      const created = await User.create(addData, { transaction: t });\r\n      await redisClient.set(`user:otp:${created.dataValues.id}`, otp, { EX: 300 });\r\n      return created;\r\n    } catch (err: any) {\r\n      // Handle unique constraint races gracefully and bubble a 409.\r\n      if (err.name === 'SequelizeUniqueConstraintError' || err?.errors?.[0]?.type === 'unique violation') {\r\n        const e: any = new Error('User already exists');\r\n        e.statusCode = 409;\r\n        throw e;\r\n      }\r\n      throw err;\r\n    }\r\n  });\r\n\r\n  await otpQueue.add(\r\n    'send-otp',\r\n    { email: user.email, otp: otp },\r\n    // {\r\n    // Use a jobId without ':' because BullMQ disallows ':' in custom ids\r\n    // (it uses ':' for internal namespacing). This prevents the \"Custom Id cannot contain :\" error.\r\n    // jobId: `otp-${user.id}`,\r\n    // }\r\n  );\r\n\r\n  return { user, otp };\r\n}\r\n\r\nexport async function verifyOtpService(email: string, otp: string, req: Request, res: Response) {\r\n  const user = await User.findOne({ where: { email }, attributes: ['id', 'email', 'is_email_verified'] });\r\n  if (!user) {\r\n    const err: any = new Error('User not found');\r\n    err.statusCode = 404;\r\n    throw err;\r\n  }\r\n\r\n  const storedOtp = await redisClient.get(`user:otp:${user.dataValues.id}`);\r\n  console.log(\"Stored OTP:\", storedOtp, \"Provided OTP:\", otp);\r\n  console.log(\"User ID:\", user.dataValues.id, \"Email:\", user.dataValues.email);\r\n  if (!storedOtp) {\r\n    const err: any = new Error('OTP expired or not found. Please request a new one.');\r\n    const newOtp = Math.floor(100000 + Math.random() * 900000).toString();\r\n    await redisClient.set(`user:otp:${user.dataValues.id}`, newOtp, { EX: 300 });\r\n    await otpQueue.add('send-otp', { email: user.dataValues.email, otp: newOtp });\r\n    err.statusCode = 400;\r\n    throw err;\r\n  }\r\n  if (storedOtp !== otp) {\r\n    const err: any = new Error('Invalid OTP');\r\n    err.statusCode = 400;\r\n    throw err;\r\n  }\r\n\r\n  await User.update({ is_email_verified: true }, { where: { email } });\r\n  await redisClient.del(`user:otp:${user.dataValues.id}`);\r\n\r\n  if (!process.env.JWT_SECRET) throw new Error('JWT_SECRET is not defined in environment variables');\r\n  // Sign token with the expected claims (issuer & audience) and a 'userId' field\r\n  // so the auth middleware's jwt.verify calls succeed.\r\n\r\n  const deviceId = v4();\r\n  const jti = v4();\r\n  const accessToken = generateAccessToken({\r\n    id: user.dataValues.id!,\r\n    email: user.dataValues.email!,\r\n    deviceId: deviceId,\r\n    jti: jti\r\n  });\r\n  const refreshToken = await createRefreshToken(user.dataValues.id, req);\r\n  setRefreshTokenCookie(res, refreshToken);\r\n  const redisKeyGen = redisKey(\"session\", user.dataValues.id, deviceId, jti);\r\n  await redisClient.set(redisKeyGen, accessToken, { EX: 60 * 60 }); // 1 hour\r\n  return { token: accessToken };\r\n}\r\n\r\nexport async function loginUserService(email: string, otpOrPassword: string, req: Request, res: Response) {\r\n  const user = await User.findOne({ where: { email, block: false }, attributes: ['id', 'email', 'password', 'is_email_verified'] });\r\n  if (!user) {\r\n    const err: any = new Error('User not found');\r\n    err.statusCode = 404;\r\n    throw err;\r\n  }\r\n  if (!user.dataValues.is_email_verified) {\r\n    const err: any = new Error('Email not verified');\r\n    err.statusCode = 403;\r\n    throw err;\r\n  }\r\n\r\n  const passwordMatch = await bcrypt.compare(otpOrPassword, user.dataValues.password);\r\n  if (!passwordMatch) {\r\n    const err: any = new Error('Invalid credentials');\r\n    err.statusCode = 401;\r\n    throw err;\r\n  }\r\n  if (!process.env.JWT_SECRET) throw new Error('JWT_SECRET is not defined in environment variables');\r\n  const deviceId = v4()\r\n  const jti = v4();\r\n  // 1) access token\r\n  const accessToken = generateAccessToken({\r\n    id: user.dataValues.id!,\r\n    email: user.dataValues.email!,\r\n    deviceId: deviceId,\r\n    jti: jti\r\n  });\r\n\r\n  // 2) refresh token + cookie\r\n  const refreshToken = await createRefreshToken(user.dataValues.id!, req);\r\n  setRefreshTokenCookie(res, refreshToken);\r\n\r\n  let redisKeyGen = redisKey(\"session\", user.dataValues.id, deviceId, jti);\r\n  await redisClient.set(redisKeyGen, accessToken, { EX: 60 * 60 }); // 20 seconds\r\n  return { token: accessToken }\r\n\r\n}\r\n\r\nexport async function getUserProfileService(userId: number) {\r\n  const user = await User.findOne({\r\n    where: { id: userId, block: false },\r\n    attributes: ['id', 'email', 'name', 'is_email_verified', 'profile_url', 'created_at', 'updated_at', 'bio', 'location', 'website', 'github', 'twitter'],\r\n  });\r\n  if (!user) {\r\n    const err: any = new Error('User not found');\r\n    err.statusCode = 404;\r\n    throw err;\r\n  }\r\n  return user;\r\n}\r\n\r\nexport async function updateUserProfileService(userId: number, body: Record<string, unknown>) {\r\n  const user = await User.findOne({ where: { id: userId, block: false } });\r\n  if (!user) {\r\n    const err: any = new Error('User not found');\r\n    err.statusCode = 404;\r\n    throw err;\r\n  }\r\n  await User.update(body, { where: { id: userId } });\r\n  return {};\r\n}\r\n\r\nexport async function blockUserService(userId: number) {\r\n  const user = await User.findOne({ where: { id: userId, block: false } });\r\n  if (!user) {\r\n    const err: any = new Error('User not found');\r\n    err.statusCode = 404;\r\n    throw err;\r\n  }\r\n  await User.update({ block: true, blocked_on: new Date() }, { where: { id: userId } });\r\n  return {};\r\n}\r\n\r\nexport async function forgotPasswordOtpService(email: string) {\r\n  const user = await User.findOne({ where: { email, block: false } });\r\n  if (!user) {\r\n    const err: any = new Error('User not found');\r\n    err.statusCode = 404;\r\n    throw err;\r\n  }\r\n\r\n  if (!user.dataValues.is_email_verified) {\r\n    const err: any = new Error('Email not verified');\r\n    err.statusCode = 403;\r\n    throw err;\r\n  }\r\n\r\n  const otp = Math.floor(100000 + Math.random() * 900000).toString();\r\n  await redisClient.set(`user:password-reset-otp:${user.dataValues.id}`, otp, { EX: 300 }); // 5 minutes\r\n\r\n  await otpQueue.add('send-password-reset-otp', { email: user.dataValues.email, otp: parseInt(otp) });\r\n\r\n  return { message: 'Password reset OTP sent to your email' };\r\n}\r\n\r\nexport async function forgotPasswordLinkService(email: string) {\r\n  const user = await User.findOne({ where: { email, block: false } });\r\n  if (!user) {\r\n    const err: any = new Error('User not found');\r\n    err.statusCode = 404;\r\n    throw err;\r\n  }\r\n\r\n  if (!user.dataValues.is_email_verified) {\r\n    const err: any = new Error('Email not verified');\r\n    err.statusCode = 403;\r\n    throw err;\r\n  }\r\n\r\n  const resetToken = crypto.randomBytes(32).toString('hex');\r\n  await redisClient.set(`user:password-reset-token:${resetToken}`, user.dataValues.id!.toString(), { EX: 900 }); // 15 minutes\r\n\r\n  const resetLink = `${process.env.FRONTEND_URL || 'http://localhost:3000'}/reset-password?token=${resetToken}`;\r\n\r\n  await otpQueue.add('send-password-reset-link', { email: user.dataValues.email, resetLink });\r\n\r\n  return { message: 'Password reset link sent to your email' };\r\n}\r\n\r\nexport async function resetPasswordWithOtpService(email: string, otp: string, newPassword: string) {\r\n  const user = await User.findOne({ where: { email, block: false } });\r\n  if (!user) {\r\n    const err: any = new Error('User not found');\r\n    err.statusCode = 404;\r\n    throw err;\r\n  }\r\n\r\n  const storedOtp = await redisClient.get(`user:password-reset-otp:${user.dataValues.id}`);\r\n  if (!storedOtp) {\r\n    const err: any = new Error('OTP expired or not found. Please request a new one.');\r\n    err.statusCode = 400;\r\n    throw err;\r\n  }\r\n\r\n  if (storedOtp !== otp) {\r\n    const err: any = new Error('Invalid OTP');\r\n    err.statusCode = 400;\r\n    throw err;\r\n  }\r\n\r\n  const hashedPassword = await bcrypt.hash(newPassword, 12);\r\n  await User.update({ password: hashedPassword }, { where: { email } });\r\n  await redisClient.del(`user:password-reset-otp:${user.dataValues.id}`);\r\n\r\n  return { message: 'Password reset successfully' };\r\n}\r\n\r\nexport async function resetPasswordWithTokenService(token: string, newPassword: string) {\r\n  const userId = await redisClient.get(`user:password-reset-token:${token}`);\r\n  if (!userId) {\r\n    const err: any = new Error('Invalid or expired reset token');\r\n    err.statusCode = 400;\r\n    throw err;\r\n  }\r\n\r\n  const user = await User.findOne({ where: { id: parseInt(userId), block: false } });\r\n  if (!user) {\r\n    const err: any = new Error('User not found');\r\n    err.statusCode = 404;\r\n    throw err;\r\n  }\r\n\r\n  const hashedPassword = await bcrypt.hash(newPassword, 12);\r\n  await User.update({ password: hashedPassword }, { where: { id: parseInt(userId) } });\r\n  await redisClient.del(`user:password-reset-token:${token}`);\r\n\r\n  return { message: 'Password reset successfully' };\r\n}\r\n"],
  "mappings": "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",
  "names": ["bcrypt", "redisClient", "crypto"]
}
