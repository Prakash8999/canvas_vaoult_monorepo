{
  "version": 3,
  "sources": ["../../../../../../src/modules/notes/notes.service.ts"],
  "sourcesContent": ["import { AllTagEntry, ExtractedNote, NoteCreationAttributes, NoteUpdateAttributes, TagNoteRef } from \"./notes.model\";\r\n// import { SyncEventLog } from \"./syncEventLog.model\";\r\n// import { SyncEvent, Conflict, UpdatedResource } from \"./sync.schema\";\r\nimport { Op, Transaction } from 'sequelize';\r\n\r\n\r\n\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { WikiLink, Note } from \"../shared/model/model.relation\";\r\nimport sequelize from \"../../config/database\";\r\nimport redisClient from \"../../config/redis\";\r\n\r\n\r\n\r\n// Helper: Deletes all list caches recorded in the user's tracker\r\nconst invalidateUserCache = async (userId: number) => {\r\n\tconst trackerKey = `user:${userId}:cache_tracker`;\r\n\tconst keysToDelete = await redisClient.sMembers(trackerKey);\r\n\r\n\tif (keysToDelete.length > 0) {\r\n\t\tconst pipeline = redisClient.multi();\r\n\t\tpipeline.del(keysToDelete); // Delete the actual cached lists\r\n\t\tpipeline.del(trackerKey);   // Delete the tracker itself\r\n\t\tawait pipeline.exec();\r\n\t\tconsole.log(`Invalidated ${keysToDelete.length} cache keys for user ${userId}`);\r\n\t}\r\n};\r\n\r\n\r\n\r\n\r\n\r\nexport const createNoteService = async (data: NoteCreationAttributes, userId: number): Promise<Note> => {\r\n\ttry {\r\n\t\tconst note_uid = uuidv4();  // guaranteed unique format\r\n\t\tconst noteData = {\r\n\t\t\t...data,\r\n\t\t\tuser_id: userId,\r\n\t\t\tnote_type: 'note' as 'note',\r\n\t\t\tversion: 1,\r\n\t\t\tnote_uid,\r\n\t\t\tcreated_at: new Date(),\r\n\t\t\tupdated_at: new Date(),\r\n\t\t};\r\n\t\tif (data.is_wiki_link) {\r\n\t\t\tif (!data.parent_note_id) {\r\n\t\t\t\tthrow new Error('Parent note ID is required when creating a wiki link');\r\n\t\t\t}\r\n\r\n\t\t\tconst transaction = await sequelize.transaction();\r\n\t\t\ttry {\r\n\t\t\t\tconst note = await Note.create(noteData, { transaction });\r\n\t\t\t\tawait WikiLink.create({\r\n\t\t\t\t\tuser_id: userId,\r\n\t\t\t\t\tparent_note_id: data.parent_note_id,\r\n\t\t\t\t\tchild_note_id: note.dataValues.id,\r\n\t\t\t\t\tcreated_at: new Date(),\r\n\t\t\t\t\tupdated_at: new Date(),\r\n\t\t\t\t}, { transaction });\r\n\r\n\t\t\t\tawait transaction.commit();\r\n\t\t\t\tawait invalidateUserCache(userId);\r\n\t\t\t\treturn note;\r\n\t\t\t} catch (error) {\r\n\t\t\t\tawait transaction.rollback();\r\n\t\t\t\tthrow error;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tconst note = await Note.create(noteData);\r\n\t\t\tawait invalidateUserCache(userId);\r\n\t\t\treturn note;\r\n\t\t}\r\n\t} catch (error) {\r\n\t\tconsole.error('Error creating note:', error);\r\n\t\tthrow error;\r\n\t}\r\n};\r\n\r\nexport const extractTagsFromContent = (content: any): string[] => {\r\n\tif (!content?.blocks) return [];\r\n\r\n\t// const tags = new Set<string>();\r\n\tconst tags: string[] = [];\r\n\tconst tagRegex = /#([a-zA-Z0-9_]+)/g;\r\n\r\n\tfor (const block of content.blocks) {\r\n\t\tlet text = \"\";\r\n\r\n\t\t// paragraph, quote, header, etc.\r\n\t\tif (block.data?.text) {\r\n\t\t\ttext = block.data.text;\r\n\t\t}\r\n\r\n\t\t// list items stored in block.data.items[].content\r\n\t\tif (block.type === \"list\" && Array.isArray(block.data?.items)) {\r\n\t\t\tblock.data.items.forEach((item: any) => {\r\n\t\t\t\tif (typeof item.content === \"string\") {\r\n\t\t\t\t\ttext += \" \" + item.content;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// extract tags inside text\r\n\t\tlet match;\r\n\t\twhile ((match = tagRegex.exec(text)) !== null) {\r\n\t\t\ttags.push(match[1].toLowerCase());\r\n\t\t}\r\n\t}\r\n\r\n\treturn Array.from(tags);\r\n};\r\n\r\n\r\n\r\n/**\r\n * Build global allTags list from notes array.\r\n * Each note already contains tags: string[]\r\n */\r\nexport function buildAllTags(notes: ExtractedNote[]): AllTagEntry[] {\r\n\tconst tagMap: Record<string, TagNoteRef[]> = {};\r\n\r\n\tfor (const note of notes) {\r\n\t\tconst uniqueTags = new Set(note.tags);\r\n\r\n\t\tfor (const tag of uniqueTags) {\r\n\t\t\tif (!tagMap[tag]) tagMap[tag] = [];\r\n\r\n\t\t\t// Prevent adding same note twice\r\n\t\t\tif (!tagMap[tag].some(n => n.note_id === note.id)) {\r\n\t\t\t\ttagMap[tag].push({\r\n\t\t\t\t\tnote_name: note.title,\r\n\t\t\t\t\tnote_uid: note.note_uid,\r\n\t\t\t\t\tnote_id: note.id,\r\n\t\t\t\t\tcreated_at: note.created_at,\r\n\t\t\t\t\tupdated_at: note.updated_at,\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn Object.entries(tagMap).map(([tag, notes]) => ({\r\n\t\ttag,\r\n\t\tnotes\r\n\t}));\r\n}\r\n\r\nexport const getAllNotesService = async (userId: number, limit?: number, offset?: number, search?: string, isWikilink: boolean = false, isGraph: boolean = false, isPinned: boolean = false): Promise<{ notes: Note[], total: number }> => {\r\n\ttry {\r\n\r\n\r\n\t\tconst redisKeyGen = `notes:${userId}:${limit}:${offset || 0}:${search || ''}:${isWikilink}:${isGraph}:${isPinned}`;\r\n\t\tconst trackerKey = `user:${userId}:cache_tracker`;\r\n\t\tconst cachedNotes = await redisClient.get(redisKeyGen);\r\n\t\tif (cachedNotes) {\r\n\t\t\tconsole.log('Notes found in cache');\r\n\t\t\treturn JSON.parse(cachedNotes);\r\n\t\t}\r\n\r\n\t\tconsole.log('Notes does not found in cache');\r\n\r\n\r\n\t\tconst whereClause: any = { user_id: userId, note_type: 'note' };\r\n\t\tif (search) {\r\n\r\n\t\t\twhereClause.title = isWikilink\r\n\t\t\t\t? search                     // exact match\r\n\t\t\t\t: { [Op.iLike]: `%${search}%` };\r\n\t\t}\r\n\t\tif (isPinned) {\r\n\t\t\twhereClause.pinned = true;\r\n\t\t}\r\n\t\tconst includeOptions = isGraph ? [\r\n\t\t\t{\r\n\t\t\t\tmodel: WikiLink,\r\n\t\t\t\tas: 'parent_wikilinks',\r\n\t\t\t\tinclude: [{\r\n\t\t\t\t\tmodel: Note,\r\n\t\t\t\t\tas: 'parent_note',\r\n\t\t\t\t\tattributes: ['id', 'title', 'note_uid', 'created_at', 'updated_at']\r\n\t\t\t\t}]\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tmodel: WikiLink,\r\n\t\t\t\tas: 'child_wikilinks',\r\n\t\t\t\tinclude: [{\r\n\t\t\t\t\tmodel: Note,\r\n\t\t\t\t\tas: 'child_note',\r\n\t\t\t\t\tattributes: ['id', 'title', 'note_uid', 'created_at', 'updated_at']\r\n\t\t\t\t}]\r\n\t\t\t}\r\n\t\t] : [];\r\n\r\n\t\tconst { count, rows } = await Note.findAndCountAll({\r\n\t\t\twhere: whereClause,\r\n\t\t\torder: [['updated_at', 'DESC']],\r\n\t\t\tlimit: limit || 50,\r\n\t\t\toffset: offset || 0,\r\n\t\t\tattributes: isWikilink ? { exclude: ['content'] } : undefined,\r\n\t\t\tinclude: includeOptions,\r\n\t\t\traw: true,\r\n\t\t\tnest: true,\r\n\t\t});\r\n\r\n\t\t// await redisClient.set(redisKeyGen, JSON.stringify({ notes: rows, total: count }), {\r\n\t\t// \tEX: 60 * 60,\r\n\t\t// });\r\n\r\n\r\n\r\n\t\tconst responseData = { notes: rows, total: count };\r\n\t\tconst pipeline = redisClient.multi();\r\n\t\tpipeline.set(redisKeyGen, JSON.stringify(responseData), {\r\n\t\t\tEX: 60 * 60,\r\n\t\t});\r\n\t\tpipeline.sAdd(trackerKey, redisKeyGen);\r\n\t\tpipeline.expire(trackerKey, 60 * 60);\r\n\r\n\t\tawait pipeline.exec();\r\n\r\n\r\n\r\n\r\n\t\treturn { notes: rows, total: count };\r\n\t} catch (error) {\r\n\t\tconsole.error('Error fetching notes:', error);\r\n\t\tthrow error;\r\n\t}\r\n};\r\n\r\nexport const getNoteByIdService = async (uid: string, userId: number): Promise<Note | null> => {\r\n\ttry {\r\n\t\tconst cacheKey = `note:${uid}:${userId}`;\r\n\r\n\t\tconst cachedNote = await redisClient.get(cacheKey);\r\n\t\tif (cachedNote) {\r\n\t\t\tconsole.log('Note found in cache');\r\n\t\t\treturn JSON.parse(cachedNote);\r\n\t\t}\r\n\t\tconsole.log('Note does not found in cache');\r\n\r\n\r\n\r\n\r\n\r\n\t\tconst note = await Note.findOne({\r\n\t\t\twhere: { note_uid: uid, user_id: userId, note_type: 'note' },\r\n\t\t\tinclude: [\r\n\t\t\t\t{\r\n\t\t\t\t\tmodel: WikiLink,\r\n\t\t\t\t\tas: 'parent_wikilinks',\r\n\t\t\t\t\tinclude: [{\r\n\t\t\t\t\t\tmodel: Note,\r\n\t\t\t\t\t\tas: 'parent_note',\r\n\t\t\t\t\t\tattributes: ['id', 'title', 'note_uid', 'created_at', 'updated_at']\r\n\t\t\t\t\t}]\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tmodel: WikiLink,\r\n\t\t\t\t\tas: 'child_wikilinks',\r\n\t\t\t\t\tinclude: [{\r\n\t\t\t\t\t\tmodel: Note,\r\n\t\t\t\t\t\tas: 'child_note',\r\n\t\t\t\t\t\tattributes: ['id', 'title', 'note_uid', 'created_at', 'updated_at']\r\n\t\t\t\t\t}]\r\n\t\t\t\t}\r\n\t\t\t],\r\n\t\t\traw: true,\r\n\t\t\tnest: true,\r\n\t\t});\r\n\r\n\t\tif (note) {\r\n\t\t\tawait redisClient.set(cacheKey, JSON.stringify(note), {\r\n\t\t\t\tEX: 60 * 30, // Cache for 30 minutes\r\n\t\t\t});\r\n\t\t}\r\n\t\tconsole.log('Fetched note by uid:', uid, note ? 'found' : 'not found');\r\n\t\treturn note;\r\n\t} catch (error) {\r\n\t\tconsole.error('Error fetching note:', error);\r\n\t\tthrow error;\r\n\t}\r\n};\r\n\r\nexport const updateNoteService = async (\r\n\tid: number,\r\n\tdata: NoteUpdateAttributes,\r\n\tuserId: number\r\n): Promise<Note | null> => {\r\n\tconst transaction: Transaction = await sequelize.transaction();\r\n\r\n\ttry {\r\n\t\t// 1. Check note ownership\r\n\t\tconst existingNote = await Note.findOne({\r\n\t\t\twhere: { id, user_id: userId, note_type: 'note' },\r\n\t\t\ttransaction,\r\n\t\t});\r\n\r\n\t\tif (!existingNote) {\r\n\t\t\tthrow new Error(\"Note not found\");\r\n\t\t}\r\n\r\n\t\t// 2. Version increment\r\n\t\tconst currentVersion: number = existingNote.dataValues.version || 0;\r\n\r\n\t\tconst updateData = {\r\n\t\t\t...data,\r\n\t\t\tversion: currentVersion + 1,\r\n\t\t\tupdated_at: new Date(),\r\n\t\t};\r\n\r\n\t\t// 3. Validate wiki link\r\n\t\tif (data.is_wiki_link && !data.child_note_id) {\r\n\t\t\tthrow new Error(\"Child note ID is required when updating a wiki link\");\r\n\t\t}\r\n\r\n\t\t// 4. Update note inside transaction\r\n\t\tawait Note.update(updateData, {\r\n\t\t\twhere: { id, user_id: userId },\r\n\t\t\ttransaction,\r\n\t\t});\r\n\r\n\t\t// 5. Create WikiLink if applicable\r\n\t\tif (data.is_wiki_link && data.child_note_id) {\r\n\t\t\tawait WikiLink.create(\r\n\t\t\t\t{\r\n\t\t\t\t\tuser_id: userId,\r\n\t\t\t\t\tparent_note_id: id,\r\n\t\t\t\t\tchild_note_id: data.child_note_id,\r\n\t\t\t\t\tcreated_at: new Date(),\r\n\t\t\t\t\tupdated_at: new Date(),\r\n\t\t\t\t},\r\n\t\t\t\t{ transaction }\r\n\t\t\t);\r\n\t\t}\r\n\t\tawait redisClient.del(`note:${existingNote.dataValues.note_uid}:${userId}`);\r\n\t\tawait invalidateUserCache(userId);\r\n\t\t// 6. Commit transaction\r\n\t\tawait transaction.commit();\r\n\r\n\r\n\t\t// 7. Fetch and return updated note\r\n\t\treturn await Note.findByPk(id);\r\n\r\n\t} catch (error) {\r\n\t\tconsole.error(\"Error updating note:\", error);\r\n\r\n\t\t// Rollback transaction on error\r\n\t\tawait transaction.rollback();\r\n\r\n\t\tthrow error;\r\n\t}\r\n};\r\n\r\nexport const deleteNoteService = async (id: number, userId: number): Promise<boolean> => {\r\n\ttry {\r\n\t\tconst note = await Note.findOne({\r\n\t\t\twhere: { id: id, user_id: userId, note_type: 'note' },\r\n\t\t\traw: true,\r\n\t\t\tattributes: ['note_uid']\r\n\t\t});\r\n\t\tif (!note) {\r\n\t\t\treturn false\r\n\r\n\t\t}\r\n\r\n\t\tconst deletedRows = await Note.destroy({\r\n\t\t\twhere: { id, user_id: userId }\r\n\t\t});\r\n\r\n\t\tif (deletedRows > 0) {\r\n\t\t\tawait redisClient.del(`note:${note.note_uid}:${userId}`);\r\n\t\t\tawait invalidateUserCache(userId);\r\n\t\t}\r\n\r\n\t\treturn deletedRows > 0;\r\n\t} catch (error) {\r\n\t\tconsole.error('Error deleting note:', error);\r\n\t\tthrow error;\r\n\t}\r\n};\r\n\r\n// Sync Operations\r\n\r\n// export const processSyncEvents = async (\r\n// \tevents: SyncEvent[], \r\n// \tclientId: string,\r\n// \tuserId: number\r\n// ): Promise<{ applied: string[], updatedResources: UpdatedResource[], conflicts: Conflict[] }> => {\r\n\r\n// \tconst applied: string[] = [];\r\n// \tconst updatedResources: UpdatedResource[] = [];\r\n// \tconst conflicts: Conflict[] = [];\r\n\r\n// \t// Use transaction for all sync operations\r\n// \tconst transaction = await sequelize.transaction();\r\n\r\n// \ttry {\r\n// \t\tfor (const event of events) {\r\n// \t\t\t// Check if event was already processed (idempotency)\r\n// \t\t\tconst existingEvent = await SyncEventLog.findOne({\r\n// \t\t\t\twhere: { event_id: event.id },\r\n// \t\t\t\ttransaction\r\n// \t\t\t});\r\n\r\n// \t\t\tif (existingEvent) {\r\n// \t\t\t\tconsole.log(`Event ${event.id} already processed, skipping`);\r\n// \t\t\t\tcontinue;\r\n// \t\t\t}\r\n\r\n// \t\t\tlet processedSuccessfully = false;\r\n// \t\t\tlet updatedNote: Note | null = null;\r\n\r\n// \t\t\ttry {\r\n// \t\t\t\tswitch (event.type) {\r\n// \t\t\t\t\tcase 'note.create':\r\n// \t\t\t\t\t\tupdatedNote = await handleCreateEvent(event, userId, transaction);\r\n// \t\t\t\t\t\tprocessedSuccessfully = true;\r\n// \t\t\t\t\t\tbreak;\r\n\r\n// \t\t\t\t\tcase 'note.update':\r\n// \t\t\t\t\t\tconst updateResult = await handleUpdateEvent(event, userId, transaction);\r\n// \t\t\t\t\t\tif (updateResult.conflict) {\r\n// \t\t\t\t\t\t\tconflicts.push(updateResult.conflict);\r\n// \t\t\t\t\t\t} else if (updateResult.note) {\r\n// \t\t\t\t\t\t\tupdatedNote = updateResult.note;\r\n// \t\t\t\t\t\t\tprocessedSuccessfully = true;\r\n// \t\t\t\t\t\t}\r\n// \t\t\t\t\t\tbreak;\r\n\r\n// \t\t\t\t\tcase 'note.delete':\r\n// \t\t\t\t\t\tawait handleDeleteEvent(event, userId, transaction);\r\n// \t\t\t\t\t\tprocessedSuccessfully = true;\r\n// \t\t\t\t\t\tbreak;\r\n\r\n// \t\t\t\t\tdefault:\r\n// \t\t\t\t\t\tconsole.error(`Unknown event type: ${event.type}`);\r\n// \t\t\t\t\t\tcontinue;\r\n// \t\t\t\t}\r\n\r\n// \t\t\t\tif (processedSuccessfully) {\r\n// \t\t\t\t\t// Log the event as processed\r\n// \t\t\t\t\tawait SyncEventLog.create({\r\n// \t\t\t\t\t\tevent_id: event.id,\r\n// \t\t\t\t\t\tclient_id: clientId,\r\n// \t\t\t\t\t\tevent_type: event.type,\r\n// \t\t\t\t\t\tresource_id: event.resourceId,\r\n// \t\t\t\t\t}, { transaction });\r\n\r\n// \t\t\t\t\tapplied.push(event.id);\r\n\r\n// \t\t\t\t\t// Add to updated resources if we have a note\r\n// \t\t\t\t\tif (updatedNote && event.type !== 'note.delete') {\r\n// \t\t\t\t\t\tupdatedResources.push({\r\n// \t\t\t\t\t\t\tid: updatedNote.id,\r\n// \t\t\t\t\t\t\ttitle: updatedNote.title,\r\n// \t\t\t\t\t\t\tcontent: updatedNote.content,\r\n// \t\t\t\t\t\t\ttags: updatedNote.tags || [],\r\n// \t\t\t\t\t\t\tversion: updatedNote.version,\r\n// \t\t\t\t\t\t\tupdated_at: updatedNote.updated_at.toISOString(),\r\n// \t\t\t\t\t\t\tpinned: updatedNote.pinned,\r\n// \t\t\t\t\t\t});\r\n// \t\t\t\t\t}\r\n// \t\t\t\t}\r\n\r\n// \t\t\t} catch (eventError) {\r\n// \t\t\t\tconsole.error(`Error processing event ${event.id}:`, eventError);\r\n// \t\t\t\t// Continue with next event rather than failing entire batch\r\n// \t\t\t}\r\n// \t\t}\r\n\r\n// \t\tawait transaction.commit();\r\n// \t\treturn { applied, updatedResources, conflicts };\r\n\r\n// \t} catch (error) {\r\n// \t\tawait transaction.rollback();\r\n// \t\tconsole.error('Error in sync transaction:', error);\r\n// \t\tthrow error;\r\n// \t}\r\n// };\r\n\r\n// const handleCreateEvent = async (event: SyncEvent, userId: number, transaction: Transaction): Promise<Note> => {\r\n// \tif (!event.payload) {\r\n// \t\tthrow new Error('Create event missing payload');\r\n// \t}\r\n\r\n// \tconst noteData: NoteCreationAttributes = {\r\n// \t\ttitle: event.payload.title || 'Untitled',\r\n// \t\tcontent: event.payload.content || { blocks: [] },\r\n// \t\ttags: event.payload.tags || [],\r\n// \t\tversion: event.payload.version || 1,\r\n// \t\tpinned: event.payload.pinned || false,\r\n// \t};\r\n\r\n// \t// Check if note with this resourceId already exists\r\n// \tconst existingNote = await Note.findOne({\r\n// \t\twhere: { \r\n// \t\t\tid: parseInt(event.resourceId),\r\n// \t\t\tuser_id: userId \r\n// \t\t},\r\n// \t\ttransaction\r\n// \t});\r\n\r\n// \tif (existingNote) {\r\n// \t\tthrow new Error(`Note with ID ${event.resourceId} already exists`);\r\n// \t}\r\n\r\n// \t// Create note data with user_id and timestamps\r\n// \tconst createData = {\r\n// \t\t...noteData,\r\n// \t\tuser_id: userId,\r\n// \t\tcreated_at: new Date(event.createdAt),\r\n// \t\tupdated_at: new Date(),\r\n// \t};\r\n\r\n// \tconst note = await Note.create(createData, { transaction });\r\n\r\n// \treturn note;\r\n// };\r\n\r\n// const handleUpdateEvent = async (\r\n// \tevent: SyncEvent, \r\n// \tuserId: number, \r\n// \ttransaction: Transaction\r\n// ): Promise<{ note?: Note, conflict?: Conflict }> => {\r\n// \tif (!event.payload) {\r\n// \t\tthrow new Error('Update event missing payload');\r\n// \t}\r\n\r\n// \tconst noteId = parseInt(event.resourceId);\r\n// \tconst existingNote = await Note.findOne({\r\n// \t\twhere: { id: noteId, user_id: userId },\r\n// \t\ttransaction\r\n// \t});\r\n\r\n// \tif (!existingNote) {\r\n// \t\tthrow new Error(`Note ${event.resourceId} not found`);\r\n// \t}\r\n\r\n// \t// Check for version conflict\r\n// \tconst clientVersion = event.payload.version;\r\n// \tif (clientVersion && clientVersion < existingNote.version) {\r\n// \t\treturn {\r\n// \t\t\tconflict: {\r\n// \t\t\t\tresourceId: event.resourceId,\r\n// \t\t\t\treason: 'version_conflict',\r\n// \t\t\t\tclientVersion: clientVersion,\r\n// \t\t\t\tserverVersion: existingNote.version,\r\n// \t\t\t\tserverState: {\r\n// \t\t\t\t\tid: existingNote.id,\r\n// \t\t\t\t\ttitle: existingNote.title,\r\n// \t\t\t\t\tcontent: existingNote.content,\r\n// \t\t\t\t\ttags: existingNote.tags,\r\n// \t\t\t\t\tversion: existingNote.version,\r\n// \t\t\t\t\tupdated_at: existingNote.updated_at.toISOString(),\r\n// \t\t\t\t\tpinned: existingNote.pinned,\r\n// \t\t\t\t}\r\n// \t\t\t}\r\n// \t\t};\r\n// \t}\r\n\r\n// \t// Apply update\r\n// \tconst updateData: Partial<NoteUpdateAttributes> = {};\r\n\r\n// \tif (event.payload.title !== undefined) updateData.title = event.payload.title;\r\n// \tif (event.payload.content !== undefined) updateData.content = event.payload.content;\r\n// \tif (event.payload.tags !== undefined) updateData.tags = event.payload.tags;\r\n// \tif (event.payload.pinned !== undefined) updateData.pinned = event.payload.pinned;\r\n\r\n// \t// Always increment version and update timestamp\r\n// \tupdateData.version = existingNote.version + 1;\r\n// \tupdateData.updated_at = new Date();\r\n\r\n// \tawait Note.update(updateData, {\r\n// \t\twhere: { id: noteId },\r\n// \t\ttransaction\r\n// \t});\r\n\r\n// \tconst updatedNote = await Note.findByPk(noteId, { transaction });\r\n// \treturn { note: updatedNote! };\r\n// };\r\n\r\n// const handleDeleteEvent = async (event: SyncEvent, userId: number, transaction: Transaction): Promise<void> => {\r\n// \tconst noteId = parseInt(event.resourceId);\r\n\r\n// \tconst deletedRows = await Note.destroy({\r\n// \t\twhere: { id: noteId, user_id: userId },\r\n// \t\ttransaction\r\n// \t});\r\n\r\n// \tif (deletedRows === 0) {\r\n// \t\tthrow new Error(`Note ${event.resourceId} not found or already deleted`);\r\n// \t}\r\n// };\r\n\r\n// Legacy methods for backward compatibility\r\nexport const addNoteCreateEvent = async (data: NoteCreationAttributes, userId: number) => {\r\n\tconst note = await createNoteService(data, userId);\r\n\treturn { success: true, note };\r\n};\r\n\r\nexport const addNoteUpdateEvent = async (id: number, data: NoteUpdateAttributes) => {\r\n\ttry {\r\n\t\tconst [affectedRows] = await Note.update(data, {\r\n\t\t\twhere: { id }\r\n\t\t});\r\n\r\n\t\tif (affectedRows === 0) {\r\n\t\t\tthrow new Error('Note not found or no changes made');\r\n\t\t}\r\n\r\n\t\tconst updatedNote = await Note.findByPk(id);\r\n\t\treturn { success: true, note: updatedNote };\r\n\t} catch (error) {\r\n\t\tconsole.error('Error updating note:', error);\r\n\t\tthrow error;\r\n\t}\r\n};\r\n\r\nexport const addNoteDeleteEvent = async (id: number) => {\r\n\ttry {\r\n\t\tconst deletedRows = await Note.destroy({\r\n\t\t\twhere: { id }\r\n\t\t});\r\n\r\n\t\tif (deletedRows === 0) {\r\n\t\t\tthrow new Error('Note not found');\r\n\t\t}\r\n\r\n\t\treturn { success: true, deletedId: id };\r\n\t} catch (error) {\r\n\t\tconsole.error('Error deleting note:', error);\r\n\t\tthrow error;\r\n\t}\r\n};\r\n\r\nexport const getNoteById = async (id: number) => {\r\n\ttry {\r\n\t\tconst note = await Note.findByPk(id);\r\n\t\treturn note;\r\n\t} catch (error) {\r\n\t\tconsole.error('Error fetching note:', error);\r\n\t\tthrow error;\r\n\t}\r\n};\r\n\r\nexport const getAllNotes = async (userId?: number) => {\r\n\ttry {\r\n\t\tconst whereClause = userId ? { user_id: userId } : {};\r\n\t\tconst notes = await Note.findAll({\r\n\t\t\twhere: whereClause,\r\n\t\t\torder: [['updated_at', 'DESC']]\r\n\t\t});\r\n\t\treturn notes;\r\n\t} catch (error) {\r\n\t\tconsole.error('Error fetching notes:', error);\r\n\t\tthrow error;\r\n\t}\r\n};\r\n\r\nexport const getNotesByIds = async (ids: number[]) => {\r\n\ttry {\r\n\t\tconst notes = await Note.findAll({\r\n\t\t\twhere: {\r\n\t\t\t\tid: {\r\n\t\t\t\t\t[Op.in]: ids\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn notes;\r\n\t} catch (error) {\r\n\t\tconsole.error('Error fetching notes by IDs:', error);\r\n\t\tthrow error;\r\n\t}\r\n};"],
  "mappings": "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",
  "names": ["redisClient", "uuidv4", "sequelize", "notes"]
}
