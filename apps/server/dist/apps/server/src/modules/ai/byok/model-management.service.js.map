{
  "version": 3,
  "sources": ["../../../../../../../src/modules/ai/byok/model-management.service.ts"],
  "sourcesContent": ["import { SupportedModel } from './supported-model.model';\r\nimport { UserAIConfig } from './user-config.model';\r\nimport { EncryptionService } from './encryption.service';\r\nimport { ApiKeyValidationService } from './key-validation.service';\r\nimport { AIProvider } from '../ai.types';\r\n\r\nexport interface SetConfigDto {\r\n    provider: string;\r\n    model: string;\r\n    apiKey?: string;\r\n    isDefault?: boolean;\r\n}\r\n\r\nexport interface ResolvedModelConfig {\r\n    provider: AIProvider;\r\n    model: string;\r\n    apiKey: string;\r\n    isUserKey: boolean;\r\n}\r\n\r\nconst DEFAULT_PROVIDER = 'gemini';\r\nconst DEFAULT_MODEL = 'gemini-2.0-flash-exp';\r\n\r\nexport class ModelManagementService {\r\n\r\n    /**\r\n     * List all supported models\r\n     */\r\n    static async getSupportedModels() {\r\n        let models = await SupportedModel.findAll({\r\n            where: { is_enabled: true },\r\n            attributes: ['provider', 'name', 'description']\r\n        });\r\n\r\n        // Simple check: if Perplexity is present but 'sonar' string is missing, OR completely empty\r\n        const hasPerplexity = models.some(m => m.provider === 'perplexity');\r\n        const hasSonar = models.some(m => m.name === 'sonar');\r\n\r\n        if (models.length === 0 || (hasPerplexity && !hasSonar)) {\r\n            await this.syncModels();\r\n            return SupportedModel.findAll({\r\n                where: { is_enabled: true },\r\n                attributes: ['provider', 'name', 'description']\r\n            });\r\n        }\r\n\r\n        return models;\r\n    }\r\n\r\n    private static async syncModels() {\r\n        // Simple, clean logic: Enforce strict list for Perplexity.\r\n        // User stated old models are already gone, so we just ensure specific legacy keys are wiped if they conflict? \r\n        // No, user said \"I have already removed it\". So strictly sync SupportedModel table.\r\n        try {\r\n            await SupportedModel.destroy({ where: { provider: 'perplexity' } });\r\n        } catch (e) {\r\n            console.warn('Failed to cleanup perplexity models', e);\r\n        }\r\n\r\n        const defaults = [\r\n            { provider: 'gemini', name: 'gemini-1.5-flash', description: 'Fast, cost-efficient multimodal model' },\r\n            { provider: 'gemini', name: 'gemini-1.5-pro', description: 'High intelligence for complex tasks' },\r\n            { provider: 'gemini', name: 'gemini-2.0-flash-exp', description: 'Next generation experimental model' },\r\n            { provider: 'perplexity', name: 'sonar', description: 'Optimized for online search and chat' },\r\n            { provider: 'perplexity', name: 'sonar-pro', description: 'Advanced reasoning and search' },\r\n        ];\r\n\r\n        for (const def of defaults) {\r\n            await SupportedModel.findOrCreate({\r\n                where: { provider: def.provider, name: def.name },\r\n                defaults: { ...def, is_enabled: true }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get user configurations (without decrypted keys)\r\n     */\r\n    static async getUserConfigs(userId: number) {\r\n        // Explicitly select attributes to ensure encrypted_api_key is fetched for check\r\n        const configs = await UserAIConfig.findAll({\r\n            where: { user_id: userId },\r\n            attributes: ['id', 'provider', 'model', 'is_default', 'created_at', 'encrypted_api_key'],\r\n            raw: true,\r\n            nest: true\r\n        });\r\n\r\n        // Map to response object with has_key\r\n        return configs.map(c => {\r\n            // Strict check for existence\r\n            const hasValues = c.encrypted_api_key !== null && c.encrypted_api_key !== undefined && c.encrypted_api_key !== '';\r\n            return {\r\n                id: c.id,\r\n                provider: c.provider,\r\n                model: c.model,\r\n                is_default: c.is_default,\r\n                created_at: c.created_at,\r\n                has_key: hasValues\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Set or Update User Configuration\r\n     */\r\n    static async setUserConfig(userId: number, dto: SetConfigDto) {\r\n        const { provider, model, apiKey, isDefault } = dto;\r\n        console.log(provider, model, apiKey, isDefault);\r\n        // 1. Validate Provider/Model is supported\r\n        const supported = await SupportedModel.findOne({ where: { provider, name: model, is_enabled: true } });\r\n        if (!supported) {\r\n            throw new Error(`Model ${provider}/${model} is not supported`);\r\n        }\r\n\r\n        let encryptedKey: string | null = null;\r\n        if (apiKey) {\r\n            // 2. Validate Key\r\n            const isValid = await ApiKeyValidationService.validate(provider, apiKey);\r\n            if (!isValid) {\r\n                // If validation failed, do NOT save\r\n                throw new Error('Invalid API Key');\r\n            }\r\n            // 3. Encrypt Key\r\n            encryptedKey = EncryptionService.encrypt(apiKey);\r\n        }\r\n\r\n        // 4. Handle Defaults (One per user)\r\n        if (isDefault) {\r\n            await UserAIConfig.update({ is_default: false }, { where: { user_id: userId } });\r\n        }\r\n\r\n        // 5. Upsert Config\r\n        const existing = await UserAIConfig.findOne({ where: { user_id: userId, provider, model } });\r\n\r\n        let result: UserAIConfig;\r\n\r\n        if (existing) {\r\n            await existing.update({\r\n                encrypted_api_key: encryptedKey ?? existing.encrypted_api_key,\r\n                is_default: isDefault ?? existing.is_default\r\n            });\r\n            await existing.reload();\r\n            result = existing;\r\n        } else {\r\n            result = await UserAIConfig.create({\r\n                user_id: userId,\r\n                provider,\r\n                model,\r\n                encrypted_api_key: encryptedKey,\r\n                is_default: isDefault || false\r\n            });\r\n        }\r\n\r\n        // Return sanitized result with has_key\r\n        // Access dataValues since result is a Sequelize instance\r\n        const encryptedApiKey = result.dataValues?.encrypted_api_key || result.encrypted_api_key;\r\n        const hasValues = encryptedApiKey !== null && encryptedApiKey !== undefined && encryptedApiKey !== '';\r\n\r\n        console.log('[ModelManagement] Returning config with has_key:', hasValues, 'encrypted_api_key length:', encryptedApiKey?.length);\r\n\r\n        return {\r\n            id: result.dataValues.id,\r\n            provider: result.dataValues.provider,\r\n            model: result.dataValues.model,\r\n            is_default: result.dataValues.is_default,\r\n            created_at: result.dataValues.created_at,\r\n            has_key: hasValues\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Delete User Configuration (API Key)\r\n     */\r\n    static async deleteUserConfig(userId: number, provider: string, model: string) {\r\n        const config = await UserAIConfig.findOne({ where: { user_id: userId, provider, model } });\r\n        if (!config) throw new Error('Configuration not found');\r\n\r\n        // Allow deleting default if they really want to? \r\n        // User asked for \"edit option\". \r\n        // If they delete, default is lost.\r\n\r\n        await config.destroy();\r\n    }\r\n\r\n    /**\r\n     * Resolve Provider, Model, and API Key for execution\r\n     */\r\n    static async resolveModelConfig(userId: number, requestedProvider?: string, requestedModel?: string, forceSystemKey?: boolean): Promise<ResolvedModelConfig> {\r\n        console.log(`[ModelManagement] Resolving config for userId: ${userId}, provider: ${requestedProvider}, model: ${requestedModel}, forceSystemKey: ${forceSystemKey}`);\r\n\r\n        let provider: string = requestedProvider || '';\r\n        let model: string = requestedModel || '';\r\n        let config: UserAIConfig | null = null;\r\n\r\n        // 1. Need Default Resolution?\r\n        if (!provider || !model) {\r\n            console.log('[ModelManagement] No provider/model specified, looking for user default...');\r\n            // Find User Default\r\n            const userDefault = await UserAIConfig.findOne({ where: { user_id: userId, is_default: true }, raw: true, nest: true });\r\n            if (userDefault) {\r\n                provider = userDefault.provider;\r\n                model = userDefault.model;\r\n                config = userDefault;\r\n                console.log(`[ModelManagement] Found user default: ${provider}/${model}, has_key: ${!!userDefault.encrypted_api_key}`);\r\n            } else {\r\n                // Fallback to System Default\r\n                provider = DEFAULT_PROVIDER;\r\n                model = DEFAULT_MODEL;\r\n                console.log(`[ModelManagement] No user default found, using system default: ${provider}/${model}`);\r\n            }\r\n        } else {\r\n            // 2. Find specific config for requested params\r\n            console.log(`[ModelManagement] Looking for specific config: ${provider}/${model}`);\r\n            config = await UserAIConfig.findOne({ where: { user_id: userId, provider, model }, raw: true, nest: true });\r\n            if (config) {\r\n                console.log(`[ModelManagement] Found config for ${provider}/${model}, has_key: ${!!config.encrypted_api_key}`);\r\n            } else {\r\n                console.log(`[ModelManagement] No config found for ${provider}/${model}`);\r\n            }\r\n        }\r\n\r\n        // 3. Resolve API Key\r\n        let apiKey = '';\r\n        let isUserKey = false;\r\n\r\n        // Only use custom key if NOT forcing system key\r\n        if (config && config.encrypted_api_key && !forceSystemKey) {\r\n            apiKey = EncryptionService.decrypt(config.encrypted_api_key);\r\n            isUserKey = true;\r\n            console.log(`[ModelManagement] Using USER key for ${provider}/${model}`);\r\n        } else {\r\n            // Use System Key\r\n            apiKey = this.getSystemKey(provider);\r\n            isUserKey = false;\r\n            console.log(`[ModelManagement] Using SYSTEM key for ${provider}/${model}`);\r\n        }\r\n\r\n        if (!apiKey) {\r\n            throw new Error(`No API key available for ${provider}`);\r\n        }\r\n\r\n        return {\r\n            provider: provider as AIProvider,\r\n            model,\r\n            apiKey,\r\n            isUserKey\r\n        };\r\n    }\r\n\r\n    private static getSystemKey(provider: string): string {\r\n        switch (provider) {\r\n            case 'gemini': return process.env.GEMINI_API_KEY || '';\r\n            case 'perplexity': return process.env.PERPLEXITY_API_KEY || '';\r\n            default: return '';\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
