{
  "version": 3,
  "sources": ["../../../../../../../src/modules/ai/services/validation.service.ts"],
  "sourcesContent": ["import { AIRequestSchema, AI_CONSTRAINTS, InvalidInputError, PROVIDER_MODELS } from '../ai.types';\r\n\r\n/**\r\n * Input Validation Service\r\n * Validates AI requests before processing\r\n * Enforces input length limits and validates provider/model combinations\r\n */\r\nexport class InputValidationService {\r\n    /**\r\n     * Validate AI request\r\n     * @param request - Request object to validate\r\n     * @throws InvalidInputError if validation fails\r\n     */\r\n    static validateRequest(request: unknown): void {\r\n        // Validate against schema\r\n        const result = AIRequestSchema.safeParse(request);\r\n\r\n        if (!result.success) {\r\n            const errors = result.error.issues.map((e: any) => e.message).join(', ');\r\n            throw new InvalidInputError(`Validation failed: ${errors}`);\r\n        }\r\n\r\n        const { provider, model, input } = result.data;\r\n\r\n        // Validate input length\r\n        this.validateInputLength(input);\r\n\r\n        // Validate provider and model combination\r\n        this.validateProviderModel(provider, model);\r\n    }\r\n\r\n    /**\r\n     * Validate input length\r\n     * @param input - Input text to validate\r\n     * @throws InvalidInputError if input exceeds limits\r\n     */\r\n    static validateInputLength(input: string): void {\r\n        if (input.length > AI_CONSTRAINTS.MAX_INPUT_LENGTH) {\r\n            throw new InvalidInputError(\r\n                `Input exceeds maximum length of ${AI_CONSTRAINTS.MAX_INPUT_LENGTH} characters. Current length: ${input.length}`\r\n            );\r\n        }\r\n\r\n        // Estimate token count (rough approximation: 1 token \u2248 4 characters)\r\n        const estimatedTokens = Math.ceil(input.length / 4);\r\n        if (estimatedTokens > AI_CONSTRAINTS.MAX_TOKEN_ESTIMATE) {\r\n            throw new InvalidInputError(\r\n                `Input exceeds estimated token limit of ${AI_CONSTRAINTS.MAX_TOKEN_ESTIMATE} tokens. Estimated: ${estimatedTokens}`\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validate provider and model combination\r\n     * @param provider - Provider name\r\n     * @param model - Model name\r\n     * @throws InvalidInputError if combination is invalid\r\n     */\r\n    static validateProviderModel(provider: string, model: string): void {\r\n        const supportedModels = PROVIDER_MODELS[provider as keyof typeof PROVIDER_MODELS] as readonly string[] | undefined;\r\n\r\n        if (!supportedModels) {\r\n            throw new InvalidInputError(\r\n                `Invalid provider: ${provider}. Supported providers: ${Object.keys(PROVIDER_MODELS).join(', ')}`\r\n            );\r\n        }\r\n\r\n        if (!supportedModels.includes(model)) {\r\n            throw new InvalidInputError(\r\n                `Model \"${model}\" is not supported for provider \"${provider}\". Supported models: ${supportedModels.join(', ')}`\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get validation constraints\r\n     * Useful for frontend to display limits\r\n     */\r\n    static getConstraints() {\r\n        return {\r\n            maxInputLength: AI_CONSTRAINTS.MAX_INPUT_LENGTH,\r\n            maxTokenEstimate: AI_CONSTRAINTS.MAX_TOKEN_ESTIMATE,\r\n            creditCostPerRequest: AI_CONSTRAINTS.CREDIT_COST_PER_REQUEST,\r\n            supportedProviders: Object.keys(PROVIDER_MODELS),\r\n            supportedModels: PROVIDER_MODELS,\r\n        };\r\n    }\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAAoF;AAO7E,MAAM,uBAAuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMhC,OAAO,gBAAgB,SAAwB;AAE3C,UAAM,SAAS,0BAAgB,UAAU,OAAO;AAEhD,QAAI,CAAC,OAAO,SAAS;AACjB,YAAM,SAAS,OAAO,MAAM,OAAO,IAAI,CAAC,MAAW,EAAE,OAAO,EAAE,KAAK,IAAI;AACvE,YAAM,IAAI,4BAAkB,sBAAsB,MAAM,EAAE;AAAA,IAC9D;AAEA,UAAM,EAAE,UAAU,OAAO,MAAM,IAAI,OAAO;AAG1C,SAAK,oBAAoB,KAAK;AAG9B,SAAK,sBAAsB,UAAU,KAAK;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,oBAAoB,OAAqB;AAC5C,QAAI,MAAM,SAAS,yBAAe,kBAAkB;AAChD,YAAM,IAAI;AAAA,QACN,mCAAmC,yBAAe,gBAAgB,gCAAgC,MAAM,MAAM;AAAA,MAClH;AAAA,IACJ;AAGA,UAAM,kBAAkB,KAAK,KAAK,MAAM,SAAS,CAAC;AAClD,QAAI,kBAAkB,yBAAe,oBAAoB;AACrD,YAAM,IAAI;AAAA,QACN,0CAA0C,yBAAe,kBAAkB,uBAAuB,eAAe;AAAA,MACrH;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAO,sBAAsB,UAAkB,OAAqB;AAChE,UAAM,kBAAkB,0BAAgB,QAAwC;AAEhF,QAAI,CAAC,iBAAiB;AAClB,YAAM,IAAI;AAAA,QACN,qBAAqB,QAAQ,0BAA0B,OAAO,KAAK,yBAAe,EAAE,KAAK,IAAI,CAAC;AAAA,MAClG;AAAA,IACJ;AAEA,QAAI,CAAC,gBAAgB,SAAS,KAAK,GAAG;AAClC,YAAM,IAAI;AAAA,QACN,UAAU,KAAK,oCAAoC,QAAQ,wBAAwB,gBAAgB,KAAK,IAAI,CAAC;AAAA,MACjH;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,iBAAiB;AACpB,WAAO;AAAA,MACH,gBAAgB,yBAAe;AAAA,MAC/B,kBAAkB,yBAAe;AAAA,MACjC,sBAAsB,yBAAe;AAAA,MACrC,oBAAoB,OAAO,KAAK,yBAAe;AAAA,MAC/C,iBAAiB;AAAA,IACrB;AAAA,EACJ;AACJ;",
  "names": []
}
