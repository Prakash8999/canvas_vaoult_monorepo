{
  "version": 3,
  "sources": ["../../../../../../src/common/utils/authTokenService.ts"],
  "sourcesContent": ["// utils/authTokens.ts\r\nimport crypto from \"crypto\";\r\nimport jwt from \"jsonwebtoken\";\r\nimport { Request, Response } from \"express\";\r\nimport AuthToken from \"../../modules/shared/model/auth/authToken.model\";\r\nimport { Op } from \"sequelize\";\r\n\r\nconst ACCESS_TOKEN_TTL = \"1d\";        // access token lifetime\r\nconst REFRESH_TOKEN_DAYS = 30;         // refresh token lifetime (days)\r\n\r\nconst validateJwtSecret = (): string => {\r\n    const secret = process.env.JWT_SECRET;\r\n    if (!secret) {\r\n        throw new Error(\"JWT_SECRET not set\");\r\n    }\r\n    return secret;\r\n};\r\n\r\nexport const generateAccessToken = (user: { id: number; email: string, deviceId: string, jti: string }) => {\r\n    const secret = validateJwtSecret();\r\n\r\n    return jwt.sign(\r\n        { userId: user.id, email: user.email, deviceId: user.deviceId, jti: user.jti },\r\n        secret,\r\n        {\r\n            expiresIn: ACCESS_TOKEN_TTL,\r\n            issuer: \"canvas-backend\",\r\n            audience: \"canvas-users\",\r\n        }\r\n    );\r\n};\r\n\r\nexport const hashToken = (token: string) =>\r\n    crypto.createHash(\"sha256\").update(token).digest(\"hex\");\r\n\r\nexport const createRefreshToken = async (\r\n    userId: number,\r\n    req: Request\r\n): Promise<string> => {\r\n    const rawToken = crypto.randomBytes(64).toString(\"hex\"); // what we give to client\r\n    const tokenHash = hashToken(rawToken);\r\n\r\n    const expires = new Date();\r\n    expires.setDate(expires.getDate() + REFRESH_TOKEN_DAYS);\r\n\r\n    const xForwardedFor = req.headers[\"x-forwarded-for\"];\r\n    const ip =\r\n        req.ip ||\r\n        (typeof xForwardedFor === \"string\"\r\n            ? xForwardedFor.split(\",\")[0].trim()\r\n            : undefined) ||\r\n        \"unknown\";\r\n\r\n    const userAgent = req.get(\"User-Agent\") || \"unknown\";\r\n    console.log(\"user agent =>\", userId)\r\n    await AuthToken.create({\r\n        user_id: userId,\r\n        token_hash: tokenHash,\r\n        ip_address: ip,\r\n        user_agent: userAgent,\r\n        revoked: false,\r\n        replaced_by_token_id: null,\r\n        expires_at: expires,\r\n    });\r\n\r\n    return rawToken;\r\n};\r\n\r\nexport const setRefreshTokenCookie = (res: Response, token: string) => {\r\n    const isProduction = process.env.NODE_ENV === \"production\";\r\n\r\n    // In development with different ports (e.g., frontend:8080, backend:3000),\r\n    // we need sameSite: 'none' and secure: true for cross-origin cookies to work\r\n    const cookieOptions = {\r\n        httpOnly: true,\r\n        secure: isProduction ? true : false, // Required for sameSite: 'none', also works in dev with https or localhost\r\n        sameSite: isProduction ? \"strict\" as const : \"lax\" as const, // 'none' allows cross-origin in dev\r\n        path: \"/\",\r\n        maxAge: 1000 * 60 * 60 * 24 * REFRESH_TOKEN_DAYS,\r\n    };\r\n\r\n    res.cookie(\"refresh_token\", token, cookieOptions);\r\n\r\n    console.log('\uD83C\uDF6A Cookie set with options:', cookieOptions);\r\n    console.log('\uD83C\uDF6A Response headers after cookie set:', res.getHeaders());\r\n};\r\n\r\nexport const clearRefreshTokenCookie = (res: Response) => {\r\n    const isProduction = process.env.NODE_ENV === \"production\";\r\n\r\n    res.clearCookie(\"refresh_token\", {\r\n        httpOnly: true,\r\n        secure: true,\r\n        sameSite: isProduction ? \"strict\" : \"none\",\r\n        path: \"/\",\r\n    });\r\n};\r\nexport const findValidRefreshSession = async (\r\n    rawToken: string,\r\n    userId?: number\r\n) => {\r\n    const tokenHash = hashToken(rawToken);\r\n    const now = new Date();\r\n\r\n    const whereOptions: any = {\r\n        token_hash: tokenHash,\r\n        revoked: false,\r\n        expires_at: { [Op.gt]: now },\r\n    };\r\n\r\n    if (userId) whereOptions.user_id = userId;\r\n\r\n    const session = await AuthToken.findOne({ where: whereOptions });\r\n\r\n    console.log(\"session =>\", session);\r\n\r\n    return session;\r\n};\r\n\r\nexport const revokeRefreshSession = async (session: AuthToken) => {\r\n    await session.update({ revoked: true });\r\n};\r\n\r\n\r\nexport const rotateRefreshToken = async (\r\n    session: AuthToken,\r\n    req: Request\r\n): Promise<string> => {\r\n    // revoke old one\r\n    session.revoked = true;\r\n\r\n    const rawToken = await createRefreshToken(session.dataValues.user_id, req);\r\n\r\n    // get new session to store relation (optional)\r\n    const tokenHash = hashToken(rawToken);\r\n    const newSession = await AuthToken.findOne({\r\n        where: { token_hash: tokenHash, user_id: session.dataValues.user_id },\r\n    });\r\n\r\n    if (newSession) {\r\n        session.replaced_by_token_id = newSession.id;\r\n    }\r\n\r\n    await session.save();\r\n\r\n    return rawToken;\r\n};\r\n"],
  "mappings": "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",
  "names": ["jwt", "crypto", "AuthToken"]
}
